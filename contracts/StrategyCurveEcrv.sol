// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {BaseStrategy} from "@yearnvaults/contracts/BaseStrategy.sol";
import {SafeERC20, SafeMath, IERC20, Address} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import {Math} from "@openzeppelin/contracts/math/Math.sol";

import {Gauge, ICurveFi, ICrvV3, IMinter} from "../interfaces/curve.sol";
import {IUniswapV2Router02} from "../interfaces/uniswap.sol";
import {IAddressResolver, ISynthetix, IExchanger} from "../interfaces/synthetix.sol";

contract StrategyCurveEcrv is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address private uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private sushiswapRouter = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    address public crvRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address[] public crvPathWeth;
    address[] public crvPathSusd;

    bytes32 public constant currencyKeySusd = "sUSD"; // 0x73555344;
    bytes32 public constant currencyKeySeth = "sETH"; // 0x73455448;

    ICurveFi public CurveStableSwap = ICurveFi(address(0xc5424B857f758E906013F3555Dad202e4bdB4567)); // Curve ETH/sETH StableSwap pool contract
    Gauge public CurveLiquidityGaugeV2 = Gauge(address(0x3C0FFFF15EA30C35d7A85B85c0782D6c94e1d238)); // Curve eCRV Gauge contract
    IAddressResolver public SynthetixResolver = IAddressResolver(address(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83)); // Synthetix AddressResolver contract

    IERC20 public WETH = IERC20(address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
    IERC20 public sETH = IERC20(address(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb));
    IERC20 public sUSD = IERC20(address(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51));
    ICrvV3 public CRV = ICrvV3(address(0xD533a949740bb3306d119CC777fa900bA034cd52));

    constructor(address _vault) public BaseStrategy(_vault) {
        want.safeApprove(address(CurveLiquidityGaugeV2), uint256(-1));
        CRV.approve(crvRouter, uint256(-1));
        sETH.approve(address(CurveStableSwap), uint256(-1));
        // sUSD.approve(address(Synthetix), uint256(-1));

        crvPathWeth = new address[](2);
        crvPathWeth[0] = address(CRV);
        crvPathWeth[1] = address(WETH);

        crvPathSusd = new address[](3);
        crvPathSusd[0] = address(CRV);
        crvPathSusd[1] = address(WETH);
        crvPathSusd[2] = address(sUSD);
    }

    function name() external view override returns (string memory) {
        return "StrategyCurveEcrv";
    }

    function estimatedTotalAssets() public view override returns (uint256) {
        return CurveLiquidityGaugeV2.balanceOf(address(this));
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        uint256 guageTokens = CurveLiquidityGaugeV2.balanceOf(address(this));
        if (guageTokens > 0) {
            CurveLiquidityGaugeV2.claim_rewards();
            IMinter(CRV.minter()).mint(address(CurveLiquidityGaugeV2));

            uint256 crvBalance = CRV.balanceOf(address(this));
            if (crvBalance > 0) {
                IExchanger synthetixExchanger = IExchanger(SynthetixResolver.getAddress("Exchanger"));
                require(address(synthetixExchanger) != address(0), "Exchanger is missing from Synthetix resolver");

                uint256[] memory amounts = IUniswapV2Router02(crvRouter).getAmountsOut(crvBalance, crvPathWeth);
                uint256 claimableWethAmount = amounts[amounts.length - 1];
                uint256 expectedLpTokensEth = CurveStableSwap.calc_token_amount([claimableWethAmount, 0], true);

                amounts = IUniswapV2Router02(crvRouter).getAmountsOut(crvBalance, crvPathSusd);
                uint256 claimableSusdAmount = amounts[amounts.length - 1];
                (uint256 claimableSethAmount, , ) =
                    synthetixExchanger.getAmountsForExchange(claimableSusdAmount, currencyKeySusd, currencyKeySeth);
                uint256 expectedLpTokensSeth = CurveStableSwap.calc_token_amount([0, claimableSethAmount], true);

                if (expectedLpTokensSeth > expectedLpTokensEth) {
                    ISynthetix synthetix = ISynthetix(SynthetixResolver.getAddress("Synthetix"));
                    require(address(synthetix) != address(0), "Synthetix is missing from Synthetix resolver");

                    IUniswapV2Router02(crvRouter).swapExactTokensForTokens(crvBalance, uint256(0), crvPathSusd, address(this), now);
                    claimableSusdAmount = sUSD.balanceOf(address(this));
                    synthetix.exchange(currencyKeySusd, claimableSusdAmount, currencyKeySeth);
                } else {
                    IUniswapV2Router02(crvRouter).swapExactTokensForETH(crvBalance, uint256(0), crvPathWeth, address(this), now);
                }
            }

            uint256 ethBalance = address(this).balance;
            uint256 sethBalance = sETH.balanceOf(address(this));
            if (ethBalance > 0 || sethBalance > 0) {
                CurveStableSwap.add_liquidity{value: ethBalance}([ethBalance, sethBalance], 0);
            }

            _profit = want.balanceOf(address(this));
        }

        if (_debtOutstanding > 0) {
            if (_debtOutstanding > _profit) {
                uint256 stakedBal = CurveLiquidityGaugeV2.balanceOf(address(this));
                CurveLiquidityGaugeV2.withdraw(Math.min(stakedBal, _debtOutstanding - _profit));
            }

            _debtPayment = Math.min(_debtOutstanding, want.balanceOf(address(this)).sub(_profit));
        }
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        uint256 _toInvest = want.balanceOf(address(this));
        CurveLiquidityGaugeV2.deposit(_toInvest);
    }

    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss) {
        uint256 wantBal = want.balanceOf(address(this));
        uint256 stakedBal = CurveLiquidityGaugeV2.balanceOf(address(this));

        if (_amountNeeded > wantBal) {
            CurveLiquidityGaugeV2.withdraw(Math.min(stakedBal, _amountNeeded - wantBal));
        }

        _liquidatedAmount = Math.min(_amountNeeded, want.balanceOf(address(this)));
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        prepareReturn(CurveLiquidityGaugeV2.balanceOf(address(this)));
    }

    function protectedTokens() internal view override returns (address[] memory) {
        address[] memory protected = new address[](1);
        protected[0] = address(CurveLiquidityGaugeV2);

        return protected;
    }

    //
    // helper functions
    //
    function setCRVRouter(
        bool isUniswap,
        address[] calldata _wethPath,
        address[] calldata _susdPath
    ) public onlyGovernance {
        if (isUniswap) {
            crvRouter = uniswapRouter;
        } else {
            crvRouter = sushiswapRouter;
        }
        crvPathWeth = _wethPath;
        crvPathSusd = _susdPath;
        CRV.approve(crvRouter, uint256(-1));
    }

    // enable ability to recieve ETH
    receive() external payable {}
}
